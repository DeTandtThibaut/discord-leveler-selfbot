"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const buffer_json_1 = __importDefault(require("buffer-json"));
const events_1 = require("events");
const get_1 = __importDefault(require("lodash/get"));
const has_1 = __importDefault(require("lodash/has"));
const set_1 = __importDefault(require("lodash/set"));
const unset_1 = __importDefault(require("lodash/unset"));
const adapters = {
    mongo: '@endb/mongo',
    mongodb: '@endb/mongo',
    mysql: '@endb/mysql',
    postgres: '@endb/postgres',
    postgresql: '@endb/postgres',
    redis: '@endb/redis',
    sqlite: '@endb/sqlite',
};
const load = (options) => {
    const validAdapters = Object.keys(adapters);
    let adapter;
    if (options.adapter) {
        adapter = options.adapter;
    }
    else if (options.uri) {
        const matches = /^[^:]+/.exec(options.uri);
        if (matches === null) {
            throw new Error(`[endb]: could not infer adapter from "${options.uri}"`);
        }
        adapter = matches[0];
    }
    if (!adapter) {
        return new Map();
    }
    if (validAdapters.includes(adapter)) {
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        const Adapter = require(adapters[adapter]).default;
        return new Adapter(options);
    }
    throw new Error(`[endb]: invalid adapter "${adapter}"`);
};
class Endb extends events_1.EventEmitter {
    constructor(options = {}) {
        super();
        const adapterOptions = {
            namespace: 'endb',
            serialize: buffer_json_1.default.stringify,
            deserialize: buffer_json_1.default.parse,
            ...(typeof options === 'string' ? { uri: options } : options),
        };
        this.options = {
            ...adapterOptions,
            store: adapterOptions.store || load(adapterOptions),
        };
        if (typeof this.options.store.on === 'function') {
            this.options.store.on('error', (error) => this.emit('error', error));
        }
        this.options.store.namespace = this.options.namespace;
    }
    async all() {
        const { store, deserialize } = this.options;
        const elements = [];
        if (store instanceof Map) {
            for (const [key, value] of store.entries()) {
                elements.push({
                    key: this.removeKeyPrefix(key),
                    value: typeof value === 'string' ? deserialize(value) : value,
                });
            }
            return elements;
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const data = await store.all();
        for (const { key, value } of data) {
            elements.push({
                key: this.removeKeyPrefix(key),
                value: typeof value === 'string' ? deserialize(value) : value,
            });
        }
        return elements;
    }
    async clear() {
        return this.options.store.clear();
    }
    async delete(key, path) {
        if (typeof path !== 'undefined') {
            const data = (await this.get(key)) || {};
            unset_1.default(data, path);
            const result = await this.set(key, data);
            return result;
        }
        const keyPrefixed = this.addKeyPrefix(key);
        return this.options.store.delete(keyPrefixed);
    }
    async entries() {
        const elements = await this.all();
        return elements.map((element) => [element.key, element.value]);
    }
    async get(key, path) {
        const keyPrefixed = this.addKeyPrefix(key);
        const { store, deserialize } = this.options;
        const serialized = await store.get(keyPrefixed);
        const deserialized = typeof serialized === 'string' ? deserialize(serialized) : serialized;
        if (deserialized === undefined)
            return undefined;
        if (typeof path !== 'undefined')
            return get_1.default(deserialized, path);
        return deserialized;
    }
    async has(key, path) {
        if (typeof path !== 'undefined') {
            const data = (await this.get(key)) || {};
            return has_1.default(data, path);
        }
        const { store } = this.options;
        const keyPrefixed = this.addKeyPrefix(key);
        const exists = await store.has(keyPrefixed);
        return exists;
    }
    async keys() {
        const elements = await this.all();
        return elements.map((element) => element.key);
    }
    async set(key, value, path) {
        const { store, serialize } = this.options;
        if (typeof path !== 'undefined') {
            const data = (await this.get(key)) || {};
            value = set_1.default(data, path, value);
        }
        const keyPrefixed = this.addKeyPrefix(key);
        const serialized = serialize(value);
        await store.set(keyPrefixed, serialized);
        return true;
    }
    async values() {
        const elements = await this.all();
        return elements.map((element) => element.value);
    }
    addKeyPrefix(key) {
        return `${this.options.namespace}:${key}`;
    }
    removeKeyPrefix(key) {
        return key.replace(`${this.options.namespace}:`, '');
    }
}
module.exports = Endb;
