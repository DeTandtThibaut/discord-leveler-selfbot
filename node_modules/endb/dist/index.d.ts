/// <reference types="node" />
import { EventEmitter } from 'events';
declare const adapters: {
    mongo: string;
    mongodb: string;
    mysql: string;
    postgres: string;
    postgresql: string;
    redis: string;
    sqlite: string;
};
declare class Endb<TVal> extends EventEmitter {
    protected readonly options: Endb.EndbOptions<TVal>;
    constructor(options?: string | Partial<Endb.EndbOptions<TVal>>);
    all(): Promise<Endb.Element<TVal>[]>;
    clear(): Promise<void>;
    delete(key: string, path?: string): Promise<boolean>;
    entries(): Promise<[string, TVal][]>;
    get(key: string, path?: string): Promise<void | any>;
    has(key: string, path?: string): Promise<boolean>;
    keys(): Promise<string[]>;
    set(key: string, value: any, path?: string): Promise<boolean>;
    values(): Promise<TVal[]>;
    private addKeyPrefix;
    private removeKeyPrefix;
}
declare namespace Endb {
    type MaybePromise<T> = T | Promise<T>;
    export interface EndbOptions<TVal, TSerialized = string> {
        namespace: string;
        store: EndbAdapter<TVal, TSerialized>;
        uri?: string;
        adapter?: keyof typeof adapters;
        serialize(data: TVal): TSerialized;
        deserialize(data: TSerialized): TVal;
    }
    export interface EndbAdapter<TVal, TSerialized = string> {
        namespace: string;
        on?(event: 'error', callback: (error: Error) => void | never): void;
        all?(): MaybePromise<Element<TSerialized>[]>;
        clear(): MaybePromise<void>;
        delete(key: string): MaybePromise<boolean>;
        get(key: string): MaybePromise<void | TVal | TSerialized>;
        has(key: string): MaybePromise<boolean>;
        set(key: string, value: TSerialized): MaybePromise<unknown>;
    }
    export interface Element<T> {
        key: string;
        value: T;
    }
    export {};
}
export = Endb;
