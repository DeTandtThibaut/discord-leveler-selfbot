/// <reference types="node" />
import { Column } from './column';
import { ColumnDefinition, TableDefinition } from './configTypes';
import { ColumnNode, ForeignKeyNode, JoinNode, LiteralNode, Node, OrderByValueNode, Query, SubQuery, TableNode } from './node';
import { INodeable } from './nodeable';
import { Sql } from './sql';
export declare type TableWithColumns<T> = Table<T> & {
    [Name in NonNullable<keyof T>]: Column<T[Name]>;
};
export declare class Table<T> implements INodeable {
    readonly nodes: Node[];
    static define<Model>(config: TableDefinition): TableWithColumns<Model>;
    columnWhiteList: boolean;
    isTemporary: boolean;
    snakeToCamel: boolean;
    columns: Array<Column<T[keyof T]>>;
    foreignKeys: ForeignKeyNode[];
    table: this;
    sql: Sql;
    engine?: string;
    charset?: string;
    alias?: string;
    initialConfig: TableDefinition;
    private schema?;
    private tableName;
    constructor(config: TableDefinition);
    clone(config?: Partial<TableDefinition>): TableWithColumns<T>;
    createColumn(col: string | ColumnDefinition | Column<any>): Column<any>;
    addColumn(col: string | ColumnDefinition | Column<any>, options?: any): this;
    hasColumn(col: Column<any> | string): boolean;
    getColumn(colName: string): Column<T[keyof T]> | null;
    get(colName: string): Column<T[keyof T]> | null;
    getSchema(): string | undefined;
    setSchema(schema: string): void;
    getName(): string;
    star(): Column<any>;
    star(options: {
        prefix: string;
    }): ColumnNode[];
    literal(literal: any): LiteralNode;
    count(alias?: string): ColumnNode;
    select(...args: any[]): Query<T>;
    subQuery(alias?: string): SubQuery<T>;
    insert(object: Array<Column<any>> | Column<any>): Query<T>;
    insert(object: Array<PartialNodeable<T>> | PartialNodeable<T>): Query<T>;
    insert(...nodes: Array<Column<any>>): Query<T>;
    replace(object: Array<Column<any>> | Column<any>): Query<T>;
    replace(object: Array<PartialNodeable<T>> | PartialNodeable<T>): Query<T>;
    replace(...nodes: Array<Column<any>>): Query<T>;
    toNode(): TableNode;
    join(other: INodeable): JoinNode;
    leftJoin(other: INodeable): JoinNode;
    joinTo(other: Table<any>): JoinNode;
    as(alias: string): TableWithColumns<T>;
    and(...args: Node[]): Query<T>;
    indexes(): IndexQuery;
}
declare type PartialNodeable<T> = {
    [P in keyof T]?: T[P] | INodeable | Buffer;
};
export interface Table<T> {
    alter(): Query<T>;
    create(): Query<T>;
    delete(table: Array<Table<any>> | Table<any> | Partial<T>): Query<T>;
    delete(): Query<T>;
    drop(): Query<T>;
    from(table: Array<Table<any>> | Table<any> | JoinNode): Query<T>;
    from(...tables: Array<Table<any>>): Query<T>;
    limit(count: any): Query<T>;
    offset(count: any): Query<T>;
    or(object: Partial<T> | Node | string): Query<T>;
    order(node: INodeable[] | INodeable): Query<T>;
    order(...nodes: INodeable[]): Query<T>;
    truncate(): Query<T>;
    update(object: PartialNodeable<T>): Query<T>;
    where(object: Partial<T> | Node[] | Node | string): Query<T>;
    where(...nodes: Node[]): Query<T>;
}
interface IndexQuery {
    create(indexName?: string): IndexCreationQuery;
    drop(indexName: string): Node;
    drop(...columns: Array<Column<any>>): Node;
}
interface IndexCreationQuery extends Node {
    unique(): IndexCreationQuery;
    using(name: string): IndexCreationQuery;
    on(...columns: Array<Column<any> | OrderByValueNode>): IndexCreationQuery;
    withParser(parserName: string): IndexCreationQuery;
    fulltext(): IndexCreationQuery;
    spatial(): IndexCreationQuery;
}
export {};
