'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const _1 = require(".");
class InsertNode extends _1.Node {
    constructor() {
        super('INSERT');
        this.names = [];
        this.columns = [];
        this.valueSets = [];
    }
    add(nodes) {
        if (!Array.isArray(nodes)) {
            throw new Error('Not an array of column instances');
        }
        let hasColumns = false;
        let hasValues = false;
        const values = {};
        nodes.forEach((node) => {
            const column = node.toNode();
            const name = column.name;
            const idx = this.names.indexOf(name);
            if (idx < 0) {
                this.names.push(name);
                this.columns.push(column);
            }
            hasColumns = true;
            hasValues = hasValues || column.value !== undefined;
            values[name] = column;
        });
        // When none of the columns have a value, it's ambiguous whether the user
        // intends to insert a row of default values or append a SELECT statement
        // later.  Resolve the ambiguity by assuming that if no columns are specified
        // it is a row of default values, otherwise a SELECT will be added.
        if (hasValues || !hasColumns) {
            this.valueSets.push(values);
        }
        return this;
    }
    /*
     * Get parameters for all values to be inserted. This function
     * handles handles bulk inserts, where keys may be present
     * in some objects and not others. When keys are not present,
     * the insert should refer to the column value as DEFAULT.
     */
    getParameters() {
        return this.valueSets.map((nodeDict) => {
            const set = [];
            this.names.forEach((name) => {
                const node = nodeDict[name];
                if (node) {
                    set.push(_1.ParameterNode.getNodeOrParameterNode(node.value));
                }
                else {
                    set.push(new _1.DefaultNode());
                }
            });
            return set;
        });
    }
}
exports.InsertNode = InsertNode;
//# sourceMappingURL=insert.js.map