import { CreateIndexNode, DropIndexNode, IAliasMixin, IValueExpressionMixinBase, JoinNode, Node, PrefixUnaryNode } from '.';
import { Column } from '../column';
import { INodeable } from '../nodeable';
import { Table } from '../table';
export declare class Query<T> extends Node {
    table: Table<T>;
    nodes: Node[];
    alias?: string;
    join?: (other: any) => JoinNode;
    private whereClause?;
    private insertClause?;
    private replaceClause?;
    private indexesClause?;
    private _select?;
    private _orderBy?;
    private _distinctOn?;
    constructor(table: Table<T>, isSubquery?: boolean);
    select(...args: any[]): this;
    star(): Column<any>;
    from(node: INodeable[] | INodeable | string): this;
    from(...nodes: INodeable[]): this;
    leftJoin(other: INodeable): JoinNode;
    where(object: Partial<T> | Node[] | Node | string): this;
    where(...nodes: Node[]): this;
    or(object: Partial<T> | Node | string): this;
    and(object: Partial<T> | Node[] | Node | string): this;
    order(node: INodeable[] | INodeable): this;
    order(...nodes: INodeable[]): this;
    group(node: INodeable[] | INodeable): this;
    group(...nodes: INodeable[]): this;
    having(node: INodeable[] | INodeable): this;
    having(...nodes: INodeable[]): this;
    insert(object: Array<Column<any>> | Column<any>): this;
    insert(object: Array<Partial<T>> | Partial<T>): this;
    insert(...nodes: Array<Column<any>>): this;
    replace(object: Array<Column<any>> | Column<any>): this;
    replace(object: Array<Partial<T>> | Partial<T>): this;
    replace(...nodes: Array<Column<any>>): this;
    update(object: Partial<T>): this;
    parameter(v: any): this;
    delete(table: Array<Table<any>> | Table<any> | Partial<T>): this;
    delete(): this;
    returning(...args: any[]): this;
    onDuplicate(object: Partial<T>): this;
    onConflict(options: {
        constraint: string;
        update?: string[];
    } | {
        columns: string[];
        update?: string[];
    }): this;
    forUpdate(): this;
    forShare(): this;
    create(indexName: string): this | CreateIndexNode;
    drop(): this | DropIndexNode;
    truncate(): this;
    distinct(): this;
    distinctOn(...args: any[]): this;
    alter(): this;
    rename(newName: Column<any> | string): this;
    addColumn(column: Column<any> | string, dataType?: string): this;
    dropColumn(column: Column<any> | string): this;
    renameColumn(oldColumn: Column<any> | string, newColumn: Column<any> | string): this;
    limit(count: any): this;
    offset(count: any): this;
    exists(): PrefixUnaryNode;
    notExists(): PrefixUnaryNode;
    ifExists(): this;
    ifNotExists(): this;
    orIgnore(): this;
    cascade(): this;
    restrict(): this;
    indexes(): this;
    createView(viewName: string): this;
}
export interface Query<T> extends IValueExpressionMixinBase, IAliasMixin {
}
export declare type SubQuery<T> = Query<T> & {
    [key: string]: Column<any>;
};
