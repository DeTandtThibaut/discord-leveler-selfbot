import { AtNode, BinaryNode, CaseNode, CastNode, InNode, NotInNode, OrderByValueNode, PostfixUnaryNode, SliceNode, TernaryNode } from '.';
import { INodeable } from '../nodeable';
export declare const valueExpressionMixin: () => {
    isNull: (this: INodeable) => any;
    isNotNull: (this: INodeable) => any;
    or: (this: INodeable, val: any) => any;
    and: (this: INodeable, val: any) => any;
    equals: (this: INodeable, val: any) => any;
    notEquals: (this: INodeable, val: any) => any;
    gt: (this: INodeable, val: any) => any;
    gte: (this: INodeable, val: any) => any;
    lt: (this: INodeable, val: any) => any;
    lte: (this: INodeable, val: any) => any;
    plus: (this: INodeable, val: any) => any;
    minus: (this: INodeable, val: any) => any;
    multiply: (this: INodeable, val: any) => any;
    divide: (this: INodeable, val: any) => any;
    modulo: (this: INodeable, val: any) => any;
    leftShift: (this: INodeable, val: any) => any;
    rightShift: (this: INodeable, val: any) => any;
    bitwiseAnd: (this: INodeable, val: any) => any;
    bitwiseNot: (this: INodeable, val: any) => any;
    bitwiseOr: (this: INodeable, val: any) => any;
    bitwiseXor: (this: INodeable, val: any) => any;
    regex: (this: INodeable, val: any) => any;
    iregex: (this: INodeable, val: any) => any;
    regexp: (this: INodeable, val: any) => any;
    notRegex: (this: INodeable, val: any) => any;
    notIregex: (this: INodeable, val: any) => any;
    concat: (this: INodeable, val: any) => any;
    key: (this: INodeable, val: any) => any;
    keyText: (this: INodeable, val: any) => any;
    path: (this: INodeable, val: any) => any;
    pathText: (this: INodeable, val: any) => any;
    like: (this: INodeable, val: any) => any;
    rlike: (this: INodeable, val: any) => any;
    notLike: (this: INodeable, val: any) => any;
    ilike: (this: INodeable, val: any) => any;
    notIlike: (this: INodeable, val: any) => any;
    match: (this: INodeable, val: any) => any;
    in: (this: INodeable, val: any) => any;
    notIn: (this: INodeable, val: any) => any;
    between: (this: INodeable, middle: any, right: any) => any;
    notBetween: (this: INodeable, middle: any, right: any) => any;
    at: (this: INodeable, index: any) => any;
    contains: (this: INodeable, val: any) => any;
    containedBy: (this: INodeable, val: any) => any;
    containsKey: (this: INodeable, val: any) => any;
    overlap: (this: INodeable, val: any) => any;
    slice: (this: INodeable, start: number, end: number) => any;
    cast: (this: INodeable, dataType: string) => any;
    descending: (this: INodeable) => OrderByValueNode;
    case: (this: INodeable, whenList: any[], thenList: any[], elseBranch?: any) => any;
};
export interface IValueExpressionMixinBase {
    isNull(): PostfixUnaryNode;
    isNotNull(): PostfixUnaryNode;
    equals(val: any): BinaryNode;
    notEquals(val: any): BinaryNode;
    gt(val: any): BinaryNode;
    gte(val: any): BinaryNode;
    lt(val: any): BinaryNode;
    lte(val: any): BinaryNode;
    plus(val: any): BinaryNode;
    minus(val: any): BinaryNode;
    multiply(val: any): BinaryNode;
    divide(val: any): BinaryNode;
    modulo(val: any): BinaryNode;
    leftShift(val: any): BinaryNode;
    rightShift(val: any): BinaryNode;
    bitwiseAnd(val: any): BinaryNode;
    bitwiseNot(val: any): BinaryNode;
    bitwiseOr(val: any): BinaryNode;
    bitwiseXor(val: any): BinaryNode;
    regex(val: any): BinaryNode;
    iregex(val: any): BinaryNode;
    regexp(val: any): BinaryNode;
    notRegex(val: any): BinaryNode;
    notIregex(val: any): BinaryNode;
    concat(val: any): BinaryNode;
    key(val: any): BinaryNode;
    keyText(val: any): BinaryNode;
    path(val: any): BinaryNode;
    pathText(val: any): BinaryNode;
    like(val: any): BinaryNode;
    rlike(val: any): BinaryNode;
    notLike(val: any): BinaryNode;
    ilike(val: any): BinaryNode;
    notIlike(val: any): BinaryNode;
    match(val: any): BinaryNode;
    in(val: any): InNode;
    notIn(val: any): NotInNode;
    between(middle: any, right: any): TernaryNode;
    notBetween(middle: any, right: any): TernaryNode;
    at(index: any): AtNode;
    contains(val: any): BinaryNode;
    containedBy(val: any): BinaryNode;
    containsKey(val: any): BinaryNode;
    overlap(val: any): BinaryNode;
    slice(start: number, end: number): SliceNode;
    cast(dataType: string): CastNode;
    descending(): OrderByValueNode;
    case(whenList: any[], thenList: any[], elseBranch?: any): CaseNode;
}
export interface IValueExpressionMixin extends IValueExpressionMixinBase {
    or(val: any): BinaryNode;
    and(val: any): BinaryNode;
}
