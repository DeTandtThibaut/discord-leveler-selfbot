'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable:object-literal-sort-keys
const _1 = require(".");
// Process values, wrapping them in ParameterNode if necessary.
const processParams = (val) => {
    return Array.isArray(val) ? val.map(_1.ParameterNode.getNodeOrParameterNode) : _1.ParameterNode.getNodeOrParameterNode(val);
};
// Value expressions can be composed to form new value expressions.
// ValueExpressionMixin is evaluated at runtime, hence the
// "thunk" around it.
exports.valueExpressionMixin = () => {
    // tslint:disable:no-shadowed-variable
    const BinaryNode = require('./binary').BinaryNode;
    const InNode = require('./in').InNode;
    const NotInNode = require('./notIn').NotInNode;
    const CastNode = require('./cast').CastNode;
    const PostfixUnaryNode = require('./postfixUnary').PostfixUnaryNode;
    const TernaryNode = require('./ternary').TernaryNode;
    const CaseNode = require('./case').CaseNode;
    const AtNode = require('./at').AtNode;
    const SliceNode = require('./slice').SliceNode;
    // tslint:enable:no-shadowed-variable
    const postfixUnaryMethod = (operator) => {
        /*jshint unused: false */
        return function () {
            return new PostfixUnaryNode({
                left: this.toNode(),
                operator
            });
        };
    };
    const binaryMethod = (operator) => {
        return function (val) {
            return new BinaryNode({
                left: this.toNode(),
                operator,
                right: processParams(val)
            });
        };
    };
    const inMethod = function (val) {
        return new InNode({
            left: this.toNode(),
            right: processParams(val)
        });
    };
    const notInMethod = function (val) {
        return new NotInNode({
            left: this.toNode(),
            right: processParams(val)
        });
    };
    const ternaryMethod = (operator, separator) => {
        return function (middle, right) {
            return new TernaryNode({
                left: this.toNode(),
                operator,
                middle: processParams(middle),
                separator,
                right: processParams(right)
            });
        };
    };
    const atMethod = function (index) {
        return new AtNode(this.toNode(), processParams(index));
    };
    const sliceMethod = function (start, end) {
        return new SliceNode(this.toNode(), processParams(start), processParams(end));
    };
    const castMethod = function (dataType) {
        return new CastNode(this.toNode(), dataType);
    };
    const orderMethod = (direction) => {
        return function () {
            return new _1.OrderByValueNode({
                value: this.toNode(),
                direction: direction ? new _1.TextNode(direction) : undefined
            });
        };
    };
    const caseMethod = function (whenList, thenList, elseBranch) {
        if (undefined !== elseBranch) {
            elseBranch = processParams(elseBranch);
        }
        return new CaseNode({
            whenList: processParams(whenList),
            thenList: processParams(thenList),
            else: elseBranch
        });
    };
    return {
        isNull: postfixUnaryMethod('IS NULL'),
        isNotNull: postfixUnaryMethod('IS NOT NULL'),
        or: binaryMethod('OR'),
        and: binaryMethod('AND'),
        equals: binaryMethod('='),
        notEquals: binaryMethod('<>'),
        gt: binaryMethod('>'),
        gte: binaryMethod('>='),
        lt: binaryMethod('<'),
        lte: binaryMethod('<='),
        plus: binaryMethod('+'),
        minus: binaryMethod('-'),
        multiply: binaryMethod('*'),
        divide: binaryMethod('/'),
        modulo: binaryMethod('%'),
        leftShift: binaryMethod('<<'),
        rightShift: binaryMethod('>>'),
        bitwiseAnd: binaryMethod('&'),
        bitwiseNot: binaryMethod('~'),
        bitwiseOr: binaryMethod('|'),
        bitwiseXor: binaryMethod('#'),
        regex: binaryMethod('~'),
        iregex: binaryMethod('~*'),
        regexp: binaryMethod('REGEXP'),
        notRegex: binaryMethod('!~'),
        notIregex: binaryMethod('!~*'),
        concat: binaryMethod('||'),
        key: binaryMethod('->'),
        keyText: binaryMethod('->>'),
        path: binaryMethod('#>'),
        pathText: binaryMethod('#>>'),
        like: binaryMethod('LIKE'),
        rlike: binaryMethod('RLIKE'),
        notLike: binaryMethod('NOT LIKE'),
        ilike: binaryMethod('ILIKE'),
        notIlike: binaryMethod('NOT ILIKE'),
        match: binaryMethod('@@'),
        in: inMethod,
        notIn: notInMethod,
        between: ternaryMethod('BETWEEN', 'AND'),
        notBetween: ternaryMethod('NOT BETWEEN', 'AND'),
        at: atMethod,
        contains: binaryMethod('@>'),
        containedBy: binaryMethod('<@'),
        containsKey: binaryMethod('?'),
        overlap: binaryMethod('&&'),
        slice: sliceMethod,
        cast: castMethod,
        descending: orderMethod('DESC'),
        case: caseMethod
    };
};
//# sourceMappingURL=valueExpression.js.map