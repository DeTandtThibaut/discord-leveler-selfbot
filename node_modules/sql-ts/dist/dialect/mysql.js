'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const _ = require("lodash");
const postgres_1 = require("./postgres");
class Mysql extends postgres_1.Postgres {
    constructor(config) {
        super(config);
        this.myClass = Mysql;
        this.quoteCharacter = '`';
        this.arrayAggFunctionName = 'GROUP_CONCAT';
    }
    _getParameterPlaceholder(index, value) {
        return '?';
    }
    _getParameterValue(value, quoteChar) {
        return Buffer.isBuffer(value)
            ? 'x' + this._getParameterValue(value.toString('hex'))
            : postgres_1.Postgres.prototype._getParameterValue.call(this, value);
    }
    visitReplace(replaceNode) {
        // don't use table.column for replaces
        this.visitedReplace = true;
        const result = [
            'REPLACE',
            ...replaceNode.nodes.map((n) => this.visit(n).join()),
            `INTO ${this.visit(this.queryNode.table.toNode())}`,
            `(${replaceNode.columns.map((n) => this.visit(n).join()).join(', ')})`
        ];
        const paramNodes = replaceNode.getParameters();
        if (paramNodes.length > 0) {
            const paramText = paramNodes
                .map((paramSet) => {
                return paramSet.map((param) => this.visit(param).join()).join(', ');
            })
                .map((param) => `(${param})`)
                .join(', ');
            result.push('VALUES', paramText);
            if (result.slice(2, 5).join(' ') === '() VALUES ()') {
                result.splice(2, 3, 'DEFAULT VALUES');
            }
        }
        this.visitedReplace = false;
        if (result[2] === 'DEFAULT VALUES') {
            result[2] = '() VALUES ()';
        }
        return result;
    }
    visitOnDuplicate(onDuplicateNode) {
        const params = [];
        /* jshint boss: true */
        for (const node of onDuplicateNode.nodes) {
            const targetCol = this.visit(node);
            params.push(`${targetCol} = ${this.visit(node.value)}`);
        }
        const result = ['ON DUPLICATE KEY UPDATE', params.join(', ')];
        return result;
    }
    visitOnConflict(onConflictNode) {
        throw new Error('Mysql does not allow onConflict clause.');
    }
    visitReturning(returningNode) {
        throw new Error('MySQL does not allow returning clause.');
    }
    visitForShare(forShareNode) {
        throw new Error('MySQL does not allow FOR SHARE clause.');
    }
    visitCreate(createNode) {
        const result = super.visitCreate(createNode);
        const engine = this.queryNode.table.initialConfig.engine;
        const charset = this.queryNode.table.initialConfig.charset;
        if (!!engine) {
            result.push('ENGINE=' + engine);
        }
        if (!!charset) {
            result.push('DEFAULT CHARSET=' + charset);
        }
        return result;
    }
    visitRenameColumn(renameColumnNode) {
        const dataType = renameColumnNode.nodes[1].dataType || renameColumnNode.nodes[0].dataType;
        assert(dataType, 'dataType missing for column ' +
            (renameColumnNode.nodes[1].name || renameColumnNode.nodes[0].name || '') +
            ' (CHANGE COLUMN statements require a dataType)');
        return [`CHANGE COLUMN ${this.visit(renameColumnNode.nodes[0])} ${this.visit(renameColumnNode.nodes[1])} ${dataType}`];
    }
    visitInsert(insertNode) {
        const result = super.visitInsert(insertNode);
        if (result[2] === 'DEFAULT VALUES') {
            result[2] = '() VALUES ()';
        }
        return result;
    }
    visitIndexes(indexesNode) {
        const tableName = this.visit(this.queryNode.table.toNode())[0];
        return [`SHOW INDEX FROM ${tableName}`];
    }
    visitBinary(binaryNode) {
        if (binaryNode.operator === '@@') {
            return [`(MATCH ${this.visit(binaryNode.left)} AGAINST ${this.visit(binaryNode.right)})`];
        }
        return super.visitBinary(binaryNode);
    }
    visitFunctionCall(functionCallNode) {
        this.visitingFunctionCall = true;
        const extract = () => {
            const nodes = functionCallNode.nodes.map((n) => this.visit(n).join());
            if (nodes.length !== 1) {
                throw new Error(`Not enough parameters passed to ${functionCallNode.name} function`);
            }
            return `${functionCallNode.name}(${nodes[0]})`;
        };
        let txt = '';
        const name = functionCallNode.name;
        // Override date functions since mysql is different than postgres
        if (['YEAR', 'MONTH', 'DAY', 'HOUR'].indexOf(functionCallNode.name) >= 0) {
            txt = extract();
        }
        // Override CURRENT_TIMESTAMP function to remove parens
        else if ('CURRENT_TIMESTAMP' === functionCallNode.name) {
            txt = functionCallNode.name;
        }
        else {
            txt = `${name}(${functionCallNode.nodes.map((n) => this.visit(n).join()).join(', ')})`;
        }
        this.visitingFunctionCall = false;
        return [txt];
    }
    visitColumn(columnNode) {
        let inSelectClause = false;
        inSelectClause = !this.selectOrDeleteEndIndex;
        const isCountStarExpression = (node) => {
            if (!node.aggregator) {
                return false;
            }
            if (node.aggregator.toLowerCase() !== 'count') {
                return false;
            }
            if (!node.star) {
                return false;
            }
            return true;
        };
        const countStar = () => {
            // Implement our own since count(table.*) is invalid in Mysql
            let result = 'COUNT(*)';
            if (inSelectClause && columnNode.alias) {
                result += ` AS ${this.quote(columnNode.alias)}`;
            }
            return result;
        };
        if (isCountStarExpression(columnNode)) {
            return [countStar()];
        }
        return super.visitColumn(columnNode);
    }
    visitInterval(intervalNode) {
        let parameter;
        if (_.isNumber(intervalNode.years)) {
            parameter = _.isNumber(intervalNode.months)
                ? `'${intervalNode.years}-${intervalNode.months}' YEAR_MONTH`
                : `${intervalNode.years} YEAR`;
        }
        else if (_.isNumber(intervalNode.months)) {
            parameter = `${intervalNode.months} MONTH`;
        }
        else if (_.isNumber(intervalNode.days)) {
            parameter = `'${intervalNode.days} ${_.isNumber(intervalNode.hours) ? intervalNode.hours : 0}:${_.isNumber(intervalNode.minutes) ? intervalNode.minutes : 0}:${_.isNumber(intervalNode.seconds) ? intervalNode.seconds : 0}' DAY_SECOND`;
        }
        else {
            parameter = `'${_.isNumber(intervalNode.hours) ? intervalNode.hours : 0}:${_.isNumber(intervalNode.minutes) ? intervalNode.minutes : 0}:${_.isNumber(intervalNode.seconds) ? intervalNode.seconds : 0}' HOUR_SECOND`;
        }
        return [`INTERVAL ${parameter}`];
    }
}
exports.Mysql = Mysql;
//# sourceMappingURL=mysql.js.map