'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const _ = require("lodash");
const node_1 = require("../node");
const table_1 = require("../table");
const dialect_1 = require("./dialect");
/**
 * Config can contain:
 *
 * nullOrder: 'first' | 'last'
 *
 * @param config
 * @constructor
 */
class Postgres extends dialect_1.Dialect {
    constructor(config) {
        super(config);
        this.myClass = Postgres;
        this.arrayAggFunctionName = 'array_agg';
        this.aliasText = ' AS ';
        this.quoteCharacter = '"';
        this.disableParameterPlaceholders = false;
        this.selectOrDeleteEndIndex = 0;
        this.visitedInsert = false;
        this.visitingUpdateTargetColumn = false;
        this.visitingCreate = false;
        this.visitCreateCompoundPrimaryKey = false;
        this.visitingAlter = false;
        this.visitingCast = false;
        this.visitingWhere = false;
        this.visitingCase = false;
        this.visitedReplace = false;
        this.visitingAddColumn = false;
        this.visitingReturning = false;
        this.visitingJoin = false;
        this.visitingFunctionCall = false;
        this.output = [];
        this.params = [];
    }
    _getParameterText(index, value) {
        if (this.disableParameterPlaceholders) {
            // do not use placeholder
            return this._getParameterValue(value).toString();
        }
        else {
            // use placeholder
            return this._getParameterPlaceholder(index, value);
        }
    }
    _getParameterValue(value, quoteChar) {
        // handle primitives
        if (null === value) {
            value = 'NULL';
        }
        else if ('boolean' === typeof value) {
            value = value ? 'TRUE' : 'FALSE';
        }
        else if ('number' === typeof value) {
            // number is just number
            value = value;
        }
        else if ('string' === typeof value) {
            // string uses single quote by default
            value = this.quote(value, quoteChar || "'");
        }
        else if ('object' === typeof value) {
            if (Array.isArray(value)) {
                if (this.myClass === Postgres) {
                    // naive check to see if this is an array of objects, which
                    // is handled differently than an array of primitives
                    if (value.length && 'object' === typeof value[0] && !_.isFunction(value[0].toISOString) && !Array.isArray(value[0])) {
                        value = `'${JSON.stringify(value)}'`;
                    }
                    else {
                        // In a Postgres array, strings must be double-quoted
                        value = value.map((item) => this._getParameterValue(item, '"'));
                        value = `'{${value.join(',')}}'`;
                    }
                }
                else {
                    value = _.map(value, this._getParameterValue.bind(this));
                    value = `(${value.join(', ')})`;
                }
            }
            else if (value instanceof Date) {
                // Date object's default toString format does not get parsed well
                // Handle dates using toISOString
                value = this._getParameterValue(value.toISOString());
            }
            else if (Buffer.isBuffer(value)) {
                value = this._getParameterValue('\\x' + value.toString('hex'));
            }
            else {
                // rich object represent with string
                const strValue = value.toString();
                value = strValue === '[object Object]' ? this._getParameterValue(JSON.stringify(value)) : this._getParameterValue(strValue);
            }
        }
        else {
            throw new Error(`Unable to use ${value} in query`);
        }
        // value has been converted at this point
        return value;
    }
    _getParameterPlaceholder(index, value) {
        return '$' + index;
    }
    getQuery(queryNode) {
        // passed in a table, not a query
        if (queryNode instanceof table_1.Table) {
            queryNode = queryNode.select(queryNode.star());
        }
        this.output = this.visit(queryNode);
        // if is a create view, must replace paramaters with values
        if (this.output.indexOf('CREATE VIEW') > -1) {
            const previousFlagStatus = this.disableParameterPlaceholders;
            this.disableParameterPlaceholders = true;
            this.output = [];
            this.output = this.visit(queryNode);
            this.params = [];
            this.disableParameterPlaceholders = previousFlagStatus;
        }
        // create the query object
        const query = { text: this.output.join(' '), values: this.params };
        // reset the internal state of this builder
        this.output = [];
        this.params = [];
        return query;
    }
    getString(queryNode) {
        // switch off parameter placeholders
        const previousFlagStatus = this.disableParameterPlaceholders;
        this.disableParameterPlaceholders = true;
        let query;
        try {
            // use the same code path for query building
            query = this.getQuery(queryNode);
        }
        finally {
            // always restore the flag afterwards
            this.disableParameterPlaceholders = previousFlagStatus;
        }
        return query.text;
    }
    visit(node) {
        switch (node.type) {
            case 'QUERY':
                return this.visitQuery(node);
            case 'SUBQUERY':
                return this.visitSubquery(node);
            case 'SELECT':
                return this.visitSelect(node);
            case 'INSERT':
                return this.visitInsert(node);
            case 'REPLACE':
                return this.visitReplace(node);
            case 'UPDATE':
                return this.visitUpdate(node);
            case 'DELETE':
                return this.visitDelete(node);
            case 'CREATE':
                return this.visitCreate(node);
            case 'DROP':
                return this.visitDrop(node);
            case 'TRUNCATE':
                return this.visitTruncate(node);
            case 'DISTINCT':
                return this.visitDistinct(node);
            case 'DISTINCT ON':
                return this.visitDistinctOn(node);
            case 'ALIAS':
                return this.visitAlias(node);
            case 'ALTER':
                return this.visitAlter(node);
            case 'CAST':
                return this.visitCast(node);
            case 'FROM':
                return this.visitFrom(node);
            case 'WHERE':
                return this.visitWhere(node);
            case 'ORDER BY':
                return this.visitOrderBy(node);
            case 'ORDER BY VALUE':
                return this.visitOrderByValue(node);
            case 'GROUP BY':
                return this.visitGroupBy(node);
            case 'HAVING':
                return this.visitHaving(node);
            case 'RETURNING':
                return this.visitReturning(node);
            case 'ONDUPLICATE':
                return this.visitOnDuplicate(node);
            case 'ONCONFLICT':
                return this.visitOnConflict(node);
            case 'FOR UPDATE':
                return this.visitForUpdate(node);
            case 'FOR SHARE':
                return this.visitForShare(node);
            case 'TABLE':
                return this.visitTable(node);
            case 'COLUMN':
                return this.visitColumn(node);
            case 'FOREIGN KEY':
                return this.visitForeignKey(node);
            case 'JOIN':
                return this.visitJoin(node);
            case 'LITERAL':
                return this.visitLiteral(node);
            case 'TEXT':
                return this.visitText(node);
            case 'PARAMETER':
                return this.visitParameter(node);
            case 'DEFAULT':
                return this.visitDefault(node);
            case 'IF EXISTS':
                return this.visitIfExists(node);
            case 'IF NOT EXISTS':
                return this.visitIfNotExists(node);
            case 'OR IGNORE':
                return this.visitOrIgnore(node);
            case 'CASCADE':
                return this.visitCascade(node);
            case 'RESTRICT':
                return this.visitRestrict(node);
            case 'RENAME':
                return this.visitRename(node);
            case 'ADD COLUMN':
                return this.visitAddColumn(node);
            case 'DROP COLUMN':
                return this.visitDropColumn(node);
            case 'RENAME COLUMN':
                return this.visitRenameColumn(node);
            case 'INDEXES':
                return this.visitIndexes(node);
            case 'CREATE INDEX':
                return this.visitCreateIndex(node);
            case 'DROP INDEX':
                return this.visitDropIndex(node);
            case 'FUNCTION CALL':
                return this.visitFunctionCall(node);
            case 'ARRAY CALL':
                return this.visitArrayCall(node);
            case 'CREATE VIEW':
                return this.visitCreateView(node);
            case 'INTERVAL':
                return this.visitInterval(node);
            case 'POSTFIX UNARY':
                return this.visitPostfixUnary(node);
            case 'PREFIX UNARY':
                return this.visitPrefixUnary(node);
            case 'BINARY':
                return this.visitBinary(node);
            case 'TERNARY':
                return this.visitTernary(node);
            case 'IN':
                return this.visitIn(node);
            case 'NOT IN':
                return this.visitNotIn(node);
            case 'CASE':
                return this.visitCase(node);
            case 'AT':
                return this.visitAt(node);
            case 'SLICE':
                return this.visitSlice(node);
            case 'LIMIT':
            case 'OFFSET':
                return this.visitModifier(node);
            default:
                throw new Error(`Unrecognized node type ${node.type}`);
        }
    }
    quote(word, quoteCharacter) {
        const q = quoteCharacter != null ? quoteCharacter : this.quoteCharacter;
        // handle square brackets specially
        if (q === '[') {
            return '[' + word + ']';
        }
        else {
            return q + word.replace(new RegExp(q, 'g'), q + q) + q;
        }
    }
    visitSelect(selectNode) {
        const result = ['SELECT'];
        if (selectNode.isDistinct) {
            result.push('DISTINCT');
        }
        const distinctOnNode = selectNode.nodes.filter((node) => node.type === 'DISTINCT ON').shift();
        const nonDistinctOnNodes = selectNode.nodes.filter((node) => node.type !== 'DISTINCT ON');
        if (distinctOnNode) {
            result.push(this.visit(distinctOnNode).join());
        }
        result.push(nonDistinctOnNodes.map(this.visit.bind(this)).join(', '));
        this.selectOrDeleteEndIndex = this.output.length + result.length;
        return result;
    }
    visitInsert(insertNode) {
        // don't use table.column for inserts
        this.visitedInsert = true;
        const result = ['INSERT', ...insertNode.nodes.map((n) => this.visit(n).join())];
        result.push(`INTO ${this.visit(this.queryNode.table.toNode()).join()}`);
        result.push(`(${insertNode.columns.map(this.visit.bind(this)).join(', ')})`);
        const paramNodes = insertNode.getParameters();
        if (paramNodes.length > 0) {
            const paramText = paramNodes
                .map((paramSet) => {
                return paramSet.map((param) => this.visit(param)).join(', ');
            })
                .map((param) => `(${param})`)
                .join(', ');
            result.push('VALUES', paramText);
            if (result.slice(2, 5).join(' ') === '() VALUES ()') {
                result.splice(2, 3, 'DEFAULT VALUES');
            }
        }
        this.visitedInsert = false;
        return result;
    }
    visitReplace(replaceNode) {
        throw new Error('Postgres does not support REPLACE.');
    }
    visitUpdate(updateNode) {
        // don't auto-generate from clause
        const params = [];
        /* jshint boss: true */
        for (const node of updateNode.nodes) {
            this.visitingUpdateTargetColumn = true;
            const targetCol = this.visit(node);
            this.visitingUpdateTargetColumn = false;
            params.push(`${targetCol} = ${this.visit(node.value)}`);
        }
        const result = ['UPDATE', this.visit(this.queryNode.table.toNode()).join(), 'SET', params.join(', ')];
        return result;
    }
    visitDelete(deleteNode) {
        const result = ['DELETE'];
        if (deleteNode.nodes.length) {
            result.push(deleteNode.nodes.map(this.visit.bind(this)).join(', '));
        }
        this.selectOrDeleteEndIndex = result.length;
        return result;
    }
    visitCreate(createNode) {
        this.visitingCreate = true;
        // don't auto-generate from clause
        const table = this.queryNode.table;
        const colNodes = table.columns.map((col) => col.toNode());
        const foreignKeyNodes = table.foreignKeys;
        let result = ['CREATE TABLE'];
        if (createNode.options.isTemporary) {
            result = ['CREATE TEMPORARY TABLE'];
        }
        result = result.concat(createNode.nodes.map((n) => this.visit(n).join()));
        result.push(this.visit(table.toNode()).join());
        const primaryColNodes = colNodes.filter((n) => n.primaryKey);
        this.visitCreateCompoundPrimaryKey = primaryColNodes.length > 1;
        let colspec = `(${colNodes.map((n) => this.visit(n).join()).join(', ')}`;
        if (this.visitCreateCompoundPrimaryKey) {
            colspec += `, PRIMARY KEY (${primaryColNodes.map((node) => this.quote(node.name)).join(', ')})`;
        }
        if (foreignKeyNodes.length > 0) {
            colspec += `, ${foreignKeyNodes.map((n) => this.visit(n).join()).join(', ')}`;
        }
        colspec += ')';
        result.push(colspec);
        this.visitCreateCompoundPrimaryKey = false;
        this.visitingCreate = false;
        return result;
    }
    visitDrop(dropNode) {
        // don't auto-generate from clause
        let result = ['DROP TABLE'];
        result = result.concat(dropNode.nodes.map((n) => this.visit(n).join()));
        return result;
    }
    visitTruncate(truncateNode) {
        let result = ['TRUNCATE TABLE'];
        result = result.concat(truncateNode.nodes.map((n) => this.visit(n).join()));
        return result;
    }
    visitDistinct(distinctNode) {
        // Nothing to do here since it's handled in the SELECT clause
        return [];
    }
    visitDistinctOn(distinctOnNode) {
        return [`DISTINCT ON(${distinctOnNode.nodes.map((n) => this.visit(n).join()).join(', ')})`];
    }
    visitAlias(aliasNode) {
        const result = [this.visit(aliasNode.value) + this.aliasText + this.quote(aliasNode.alias)];
        return result;
    }
    visitAlter(alterNode) {
        this.visitingAlter = true;
        // don't auto-generate from clause
        const table = this.queryNode.table;
        const result = ['ALTER TABLE', ...this.visit(table.toNode()), alterNode.nodes.map(this.visit.bind(this)).join(', ')];
        this.visitingAlter = false;
        return result;
    }
    visitCast(castNode) {
        this.visitingCast = true;
        const result = ['CAST(' + this.visit(castNode.value) + ' AS ' + castNode.dataType + ')'];
        this.visitingCast = false;
        return result;
    }
    visitFrom(fromNode) {
        let result = [];
        if (fromNode.skipFromStatement) {
            result.push(',');
        }
        else {
            result.push('FROM');
        }
        for (const node of fromNode.nodes) {
            result = result.concat(this.visit(node));
        }
        return result;
    }
    visitWhere(whereNode) {
        this.visitingWhere = true;
        const result = ['WHERE', whereNode.nodes.map(this.visit.bind(this)).join(', ')];
        this.visitingWhere = false;
        return result;
    }
    visitOrderBy(orderByNode) {
        const result = ['ORDER BY', orderByNode.nodes.map(this.visit.bind(this)).join(', ')];
        if (this.myClass === Postgres && this.config.nullOrder) {
            result.push('NULLS ' + this.config.nullOrder.toUpperCase());
        }
        return result;
    }
    visitOrderByValue(orderByValueNode) {
        let text = this.visit(orderByValueNode.value).join();
        if (orderByValueNode.direction) {
            text += ' ' + this.visit(orderByValueNode.direction).join();
        }
        return [text];
    }
    visitGroupBy(groupByNode) {
        const result = ['GROUP BY', groupByNode.nodes.map(this.visit.bind(this)).join(', ')];
        return result;
    }
    visitHaving(havingNode) {
        const result = ['HAVING', havingNode.nodes.map(this.visit.bind(this)).join(' AND ')];
        return result;
    }
    visitPrefixUnary(prefixUnaryNode) {
        const text = '(' + prefixUnaryNode.operator + ' ' + this.visit(prefixUnaryNode.left) + ')';
        return [text];
    }
    visitPostfixUnary(postfixUnaryNode) {
        const text = '(' + this.visit(postfixUnaryNode.left) + ' ' + postfixUnaryNode.operator + ')';
        return [text];
    }
    visitBinary(binaryNode) {
        binaryNode.left.property = binaryNode.left.name;
        binaryNode.right.property = binaryNode.right.name;
        let text = `(${this.visit(binaryNode.left)} ${binaryNode.operator} `;
        if (Array.isArray(binaryNode.right)) {
            text += `(${binaryNode.right.map((node) => this.visit(node)).join(', ')})`;
        }
        else {
            text += this.visit(binaryNode.right).join();
        }
        text += ')';
        return [text];
    }
    visitTernary(ternaryNode) {
        const visitPart = (value) => {
            return Array.isArray(value) ? `(${value.map((node) => this.visit(node)).join(', ')})` : this.visit(value).join();
        };
        const text = `(${this.visit(ternaryNode.left)} ${ternaryNode.operator} ${visitPart(ternaryNode.middle)} ${ternaryNode.separator} ${visitPart(ternaryNode.right)})`;
        return [text];
    }
    visitIn(inNode) {
        let text = '(';
        if (Array.isArray(inNode.right)) {
            if (inNode.right.length) {
                const params = [];
                let hasNull = false;
                inNode.right.forEach((node) => {
                    if (node.type === 'PARAMETER' && node.value() === null) {
                        hasNull = true;
                    }
                    else {
                        params.push(this.visit(node).join());
                    }
                });
                if (params.length) {
                    text += `${this.visit(inNode.left)} IN (${params.join(', ')})`;
                    if (hasNull) {
                        text += ` OR ${this.visit(inNode.left)} IS NULL`;
                    }
                }
                else {
                    // implicitely has null
                    text += `${this.visit(inNode.left)} IS NULL`;
                }
            }
            else {
                text += '1=0';
            }
        }
        else {
            text += `${this.visit(inNode.left)} IN ${this.visit(inNode.right)}`;
        }
        text += ')';
        return [text];
    }
    visitNotIn(notInNode) {
        let text = '(';
        if (Array.isArray(notInNode.right)) {
            if (notInNode.right.length) {
                const params = [];
                let hasNull = false;
                notInNode.right.forEach((node) => {
                    if (node.type === 'PARAMETER' && node.value() === null) {
                        hasNull = true;
                    }
                    else {
                        params.push(this.visit(node).join());
                    }
                });
                if (params.length && hasNull) {
                    text += `NOT (${this.visit(notInNode.left)} IN (${params.join(', ')}) OR ${this.visit(notInNode.left)} IS NULL)`;
                }
                else if (params.length) {
                    text += `${this.visit(notInNode.left)} NOT IN (${params.join(', ')})`;
                }
                else {
                    // implicitely has null
                    text += `${this.visit(notInNode.left)} IS NOT NULL`;
                }
            }
            else {
                text += '1=1';
            }
        }
        else {
            text += `${this.visit(notInNode.left)} NOT IN ${this.visit(notInNode.right)}`;
        }
        text += ')';
        return [text];
    }
    visitCase(caseNode) {
        assert(caseNode.whenList.length === caseNode.thenList.length);
        let text = '(CASE';
        this.visitingCase = true;
        for (let i = 0; i < caseNode.whenList.length; i++) {
            text += ` WHEN ${this.visit(caseNode.whenList[i])} THEN ${this.visit(caseNode.thenList[i])}`;
        }
        if (caseNode.else != null) {
            text += ` ELSE ${this.visit(caseNode.else)}`;
        }
        this.visitingCase = false;
        text += ' END)';
        return [text];
    }
    visitAt(atNode) {
        const text = `(${this.visit(atNode.value)})[${this.visit(atNode.index)}]`;
        return [text];
    }
    visitSlice(sliceNode) {
        const text = `(${this.visit(sliceNode.value)})[${this.visit(sliceNode.start)}:${this.visit(sliceNode.end)}]`;
        return [text];
    }
    visitQuery(queryNode) {
        if (this.queryNode) {
            return this.visitSubquery(queryNode, dontParenthesizeSubQuery(this.queryNode));
        }
        this.queryNode = queryNode;
        // need to sort the top level query nodes on visitation priority
        // so select/insert/update/delete comes before from comes before where
        let missingFrom = true;
        let hasFrom = false;
        let createView;
        let isSelect = false;
        const actions = [];
        const targets = [];
        const filters = [];
        for (const node of queryNode.nodes) {
            switch (node.type) {
                case 'SELECT':
                    isSelect = true;
                case 'DELETE':
                    actions.push(node);
                    break;
                case 'INDEXES':
                case 'INSERT':
                case 'REPLACE':
                case 'UPDATE':
                case 'CREATE':
                case 'DROP':
                case 'TRUNCATE':
                case 'ALTER':
                    actions.push(node);
                    missingFrom = false;
                    break;
                case 'FROM':
                    node.skipFromStatement = hasFrom;
                    hasFrom = true;
                    missingFrom = false;
                    targets.push(node);
                    break;
                case 'CREATE VIEW':
                    createView = node;
                    break;
                default:
                    filters.push(node);
                    break;
            }
        }
        if (!actions.length) {
            // if no actions are given, guess it's a select
            actions.push(new node_1.SelectNode().add('*'));
            isSelect = true;
        }
        if (missingFrom && queryNode.table instanceof table_1.Table) {
            // the instanceof handles the situation where a sql.select(some expression) is used and there should be no FROM clause
            targets.push(new node_1.FromNode().add(queryNode.table));
        }
        if (createView) {
            if (isSelect) {
                actions.unshift(createView);
            }
            else {
                throw new Error('Create View requires a Select.');
            }
        }
        return this.visitQueryHelper(actions, targets, filters);
    }
    /**
     * We separate out this part of query building so it can be overridden by other implementations.
     *
     * @param {Node[]} actions
     * @param {Node[]} targets
     * @param {Node[]} filters
     * @returns {String[]}
     */
    visitQueryHelper(actions, targets, filters) {
        this.handleDistinct(actions, filters);
        // lazy-man sorting
        const sortedNodes = actions.concat(targets).concat(filters);
        for (const node of sortedNodes) {
            const res = this.visit(node);
            this.output = this.output.concat(res);
        }
        // implicit 'from'
        return this.output;
    }
    visitSubquery(queryNode, dontParenthesize) {
        // create another query builder of the current class to build the subquery
        const subQuery = new this.myClass(this.config);
        // let the subquery modify this instance's params array
        subQuery.params = this.params;
        // pass on the disable parameter placeholder flag
        const previousFlagStatus = subQuery.disableParameterPlaceholders;
        subQuery.disableParameterPlaceholders = this.disableParameterPlaceholders;
        try {
            subQuery.visitQuery(queryNode);
        }
        finally {
            // restore the flag
            subQuery.disableParameterPlaceholders = previousFlagStatus;
        }
        const alias = queryNode.alias;
        if (dontParenthesize) {
            return [subQuery.output.join(' ') + (alias ? ' ' + this.quote(alias) : '')];
        }
        return ['(' + subQuery.output.join(' ') + ')' + (alias ? ' ' + this.quote(alias) : '')];
    }
    visitTable(tableNode) {
        const table = tableNode.table;
        let txt = '';
        if (table.getSchema()) {
            txt = this.quote(table.getSchema());
            txt += '.';
        }
        txt += this.quote(table.getName());
        if (typeof table.alias === 'string') {
            txt += this.aliasText + this.quote(table.alias);
        }
        return [txt];
    }
    visitColumn(columnNode) {
        const table = columnNode.table;
        const inInsertUpdateClause = this.visitedInsert || this.visitedReplace || this.visitingUpdateTargetColumn;
        const inDdlClause = this.visitingAddColumn || this.visitingAlter || this.visitingCreate;
        const inSelectClause = this.visitingReturning ||
            (!this.selectOrDeleteEndIndex &&
                !this.visitingWhere &&
                !inInsertUpdateClause &&
                !inDdlClause &&
                !this.visitingCase &&
                !this.visitingJoin);
        const inFunctionCall = this.visitingFunctionCall;
        const inCast = this.visitingCast;
        const txt = [];
        let closeParen = 0;
        if (inSelectClause && ((table && !table.alias) || !!columnNode.alias)) {
            if (columnNode.asArray) {
                closeParen++;
                txt.push(`${this.arrayAggFunctionName}(`);
            }
            if (!!columnNode.aggregator) {
                closeParen++;
                txt.push(`${columnNode.aggregator}(`);
            }
            if (columnNode.isDistinct === true) {
                closeParen++;
                txt.push('DISTINCT(');
            }
        }
        if (!inInsertUpdateClause &&
            !this.visitingReturning &&
            !this.visitingCreate &&
            !this.visitingAlter &&
            !columnNode.subfieldContainer) {
            if (table) {
                if (typeof table.alias === 'string') {
                    txt.push(this.quote(table.alias));
                }
                else {
                    if (table.getSchema()) {
                        txt.push(this.quote(table.getSchema()));
                        txt.push('.');
                    }
                    txt.push(this.quote(table.getName()));
                }
                txt.push('.');
            }
        }
        if (columnNode.star) {
            const allCols = [];
            let hasAliases = false;
            if (columnNode.aggregator !== 'COUNT') {
                const tableName = txt.join('');
                for (const col of table.columns) {
                    const aliased = col.name !== (col.alias || col.property);
                    hasAliases = hasAliases || aliased;
                    allCols.push(tableName + this.quote(col.name) + (aliased ? this.aliasText + this.quote(col.alias || col.property) : ''));
                }
            }
            if (hasAliases) {
                txt.length = 0;
                txt.push(allCols.join(', '));
            }
            else {
                txt.push('*');
            }
        }
        else if (columnNode.isConstant) {
            // this injects directly into SELECT statement rather than creating a parameter
            //   txt.push(this._getParameterValue(columnNode.literalValue))
            // currently thinking it is better to generate a parameter
            const value = columnNode.constantValue;
            this.params.push(value);
            txt.push(this._getParameterText(this.params.length, value));
        }
        else {
            if (columnNode.subfieldContainer) {
                txt.push('(' + this.visitColumn(columnNode.subfieldContainer.toNode()) + ').');
            }
            txt.push(this.quote(columnNode.name));
        }
        if (closeParen) {
            for (let j = 0; j < closeParen; j++) {
                txt.push(')');
            }
        }
        if (inSelectClause && !inFunctionCall && !inCast && (columnNode.alias || columnNode.property !== columnNode.name)) {
            txt.push(this.aliasText + this.quote(columnNode.alias || columnNode.property));
        }
        if (this.visitingCreate || this.visitingAddColumn) {
            assert(columnNode.dataType, `dataType missing for column ${columnNode.name} (CREATE TABLE and ADD COLUMN statements require a dataType)`);
            txt.push(` ${columnNode.dataType}`);
            if (this.visitingCreate) {
                if (columnNode.primaryKey && !this.visitCreateCompoundPrimaryKey) {
                    // creating a column as a primary key
                    txt.push(' PRIMARY KEY');
                }
                else if (columnNode.notNull) {
                    txt.push(' NOT NULL');
                }
                if (!columnNode.primaryKey && columnNode.unique) {
                    txt.push(' UNIQUE');
                }
                if (columnNode.defaultValue !== undefined) {
                    txt.push(` DEFAULT ${this._getParameterValue(columnNode.defaultValue)}`);
                }
            }
            if (!!columnNode.references) {
                assert.equal(typeof columnNode.references, 'object', 'references is not a object for column ' +
                    columnNode.name +
                    ' (REFERENCES statements within CREATE TABLE and ADD COLUMN statements' +
                    ' require refrences to be expressed as an object)');
                // Empty refrence objects are ok
                if (Object.keys(columnNode.references).length > 0) {
                    const references = columnNode.references;
                    assert(references.table, 'reference.table missing for column ' +
                        columnNode.name +
                        ' (REFERENCES statements within CREATE TABLE and ADD COLUMN statements' +
                        ' require a table and column)');
                    assert(references.column, 'reference.column missing for column ' +
                        columnNode.name +
                        ' (REFERENCES statements within CREATE TABLE and ADD COLUMN statements' +
                        ' require a table and column)');
                    txt.push(' REFERENCES ');
                    // TODO: if this is used need to put back in
                    // if (references.schema) {
                    //     txt.push(this.quote(references.schema) + '.');
                    // }
                    txt.push(this.quote(references.table) + '(' + this.quote(references.column) + ')');
                    let onDelete = references.onDelete;
                    if (onDelete) {
                        onDelete = onDelete.toUpperCase();
                    }
                    if (onDelete === 'CASCADE' ||
                        onDelete === 'RESTRICT' ||
                        onDelete === 'SET NULL' ||
                        onDelete === 'SET DEFAULT' ||
                        onDelete === 'NO ACTION') {
                        txt.push(` ON DELETE ${onDelete}`);
                    }
                    let onUpdate = references.onUpdate;
                    if (onUpdate) {
                        onUpdate = onUpdate.toUpperCase();
                    }
                    if (onUpdate === 'CASCADE' ||
                        onUpdate === 'RESTRICT' ||
                        onUpdate === 'SET NULL' ||
                        onUpdate === 'SET DEFAULT' ||
                        onUpdate === 'NO ACTION') {
                        txt.push(` ON UPDATE ${onUpdate}`);
                    }
                    const constraint = references.constraint;
                    if (constraint) {
                        txt.push(` ${constraint.toUpperCase()}`);
                    }
                }
            }
        }
        return [txt.join('')];
    }
    visitForeignKey(foreignKeyNode) {
        const txt = [];
        if (this.visitingCreate) {
            assert(foreignKeyNode.table, 'Foreign table missing for table reference');
            assert(foreignKeyNode.columns, 'Columns missing for table reference');
            if (foreignKeyNode.refColumns !== undefined) {
                assert.equal(foreignKeyNode.columns.length, foreignKeyNode.refColumns.length, 'Number of local columns and foreign columns differ in table reference');
            }
            if (foreignKeyNode.name !== undefined) {
                txt.push('CONSTRAINT ' + this.quote(foreignKeyNode.name) + ' ');
            }
            txt.push('FOREIGN KEY ( ');
            for (let i = 0; i < foreignKeyNode.columns.length; i++) {
                if (i > 0) {
                    txt.push(', ');
                }
                txt.push(this.quote(foreignKeyNode.columns[i]));
            }
            txt.push(' ) REFERENCES ');
            if (foreignKeyNode.schema !== undefined) {
                txt.push(this.quote(foreignKeyNode.schema) + '.');
            }
            txt.push(this.quote(foreignKeyNode.table));
            if (foreignKeyNode.refColumns !== undefined) {
                txt.push(' ( ');
                for (let i = 0; i < foreignKeyNode.refColumns.length; i++) {
                    if (i > 0) {
                        txt.push(', ');
                    }
                    txt.push(this.quote(foreignKeyNode.refColumns[i]));
                }
                txt.push(' )');
            }
            let onDelete = foreignKeyNode.onDelete;
            if (onDelete) {
                onDelete = onDelete.toUpperCase();
                if (onDelete === 'CASCADE' ||
                    onDelete === 'RESTRICT' ||
                    onDelete === 'SET NULL' ||
                    onDelete === 'SET DEFAULT' ||
                    onDelete === 'NO ACTION') {
                    txt.push(` ON DELETE ${onDelete}`);
                }
            }
            let onUpdate = foreignKeyNode.onUpdate;
            if (onUpdate) {
                onUpdate = onUpdate.toUpperCase();
                if (onUpdate === 'CASCADE' ||
                    onUpdate === 'RESTRICT' ||
                    onUpdate === 'SET NULL' ||
                    onUpdate === 'SET DEFAULT' ||
                    onUpdate === 'NO ACTION') {
                    txt.push(` ON UPDATE ${onUpdate}`);
                }
            }
            if (foreignKeyNode.constraint) {
                txt.push(` ${foreignKeyNode.constraint.toUpperCase()}`);
            }
        }
        return [txt.join('')];
    }
    visitFunctionCall(functionCallNode) {
        this.visitingFunctionCall = true;
        const extract = () => {
            const nodes = functionCallNode.nodes.map(this.visit.bind(this));
            if (nodes.length !== 1) {
                throw new Error(`Not enough parameters passed to ${functionCallNode.name} function`);
            }
            return `EXTRACT(${functionCallNode.name} FROM ${nodes[0] + ''})`;
        };
        let txt = '';
        // Override date functions since postgres (and others) uses extract
        if (['YEAR', 'MONTH', 'DAY', 'HOUR'].indexOf(functionCallNode.name) >= 0) {
            txt = extract();
        }
        // Override CURRENT_TIMESTAMP function to remove parens
        else if ('CURRENT_TIMESTAMP' === functionCallNode.name) {
            txt = functionCallNode.name;
        }
        else {
            txt = `${functionCallNode.name}(${functionCallNode.nodes.map(this.visit.bind(this)).join(', ')})`;
        }
        this.visitingFunctionCall = false;
        return [txt];
    }
    visitArrayCall(arrayCallNode) {
        const txt = `ARRAY[${arrayCallNode.nodes.map(this.visit.bind(this)).join(', ')}]`;
        return [txt];
    }
    visitParameter(parameterNode) {
        // save the value into the parameters array
        const value = parameterNode.value();
        this.params.push(value);
        return parameterNode.isExplicit ? [] : [this._getParameterText(this.params.length, value)];
    }
    visitDefault(defaultNode) {
        /* jshint unused: false */
        return ['DEFAULT'];
    }
    visitAddColumn(addColumnNode) {
        this.visitingAddColumn = true;
        const result = [`ADD COLUMN ${this.visit(addColumnNode.nodes[0])}`];
        this.visitingAddColumn = false;
        return result;
    }
    visitDropColumn(dropColumnNode) {
        return [`DROP COLUMN ${this.visit(dropColumnNode.nodes[0])}`];
    }
    visitRenameColumn(renameColumnNode) {
        return [`RENAME COLUMN ${this.visit(renameColumnNode.nodes[0])} TO ${this.visit(renameColumnNode.nodes[1])}`];
    }
    visitRename(renameNode) {
        return [`RENAME TO ${this.visit(renameNode.nodes[0])}`];
    }
    visitIfExists(ifExistsNode) {
        return ['IF EXISTS'];
    }
    visitIfNotExists(ifNotExistsNode) {
        return ['IF NOT EXISTS'];
    }
    visitOrIgnore(orIgnoreNode) {
        throw new Error('PostgreSQL does not allow orIgnore clause.');
    }
    visitCascade(cascadeNode) {
        return ['CASCADE'];
    }
    visitRestrict(restrictNode) {
        return ['RESTRICT'];
    }
    visitForUpdate(forUpdateNode) {
        return ['FOR UPDATE'];
    }
    visitForShare(forShareNode) {
        return ['FOR SHARE'];
    }
    visitJoin(joinNode) {
        this.visitingJoin = true;
        return [...this.visit(joinNode.from), `${joinNode.subType} JOIN`, ...this.visit(joinNode.to), 'ON', ...this.visit(joinNode.onNode)];
    }
    visitLiteral(literalNode) {
        const txt = [literalNode.literal];
        if (literalNode.alias) {
            txt.push(this.aliasText + this.quote(literalNode.alias));
        }
        return [txt.join('')];
    }
    visitText(textNode) {
        return [textNode.text];
    }
    visitReturning(returningNode) {
        this.visitingReturning = true;
        const r = ['RETURNING', returningNode.nodes.map(this.visit.bind(this)).join(', ')];
        this.visitingReturning = false;
        return r;
    }
    visitOnDuplicate(onDuplicateNode) {
        throw new Error('PostgreSQL does not allow onDuplicate clause.');
    }
    visitOnConflict(onConflictNode) {
        const result = ['ON CONFLICT'];
        const columns = [];
        const updateClause = [];
        let i;
        let col;
        const table = this.queryNode.table;
        if (onConflictNode.constraint) {
            result.push(['ON CONSTRAINT', this.quote(onConflictNode.constraint)].join(' '));
        }
        else if (onConflictNode.columns) {
            for (i = 0; i < onConflictNode.columns.length; i++) {
                columns.push(this.quote(table.getColumn(onConflictNode.columns[i]).name));
            }
            result.push('(' + columns.join(', ') + ')');
        }
        if (onConflictNode.update) {
            updateClause.push('DO UPDATE SET');
            const update = onConflictNode.update;
            const setClause = [];
            for (i = 0; i < update.length; i++) {
                col = this.quote(table.getColumn(update[i]).name);
                setClause.push(col + ' = EXCLUDED.' + col);
            }
            updateClause.push(setClause.join(', '));
        }
        else {
            updateClause.push('DO NOTHING');
        }
        result.push(updateClause.join(' '));
        return result;
    }
    visitModifier(modifierNode) {
        return [modifierNode.type, ...this.visit(modifierNode.count)];
    }
    visitIndexes(indexesNode) {
        /* jshint unused: false */
        const tableName = this.queryNode.table.getName();
        const schemaName = this.queryNode.table.getSchema() || 'public';
        return [
            'SELECT relname',
            'FROM pg_class',
            'WHERE oid IN (',
            'SELECT indexrelid',
            `FROM pg_index, pg_class WHERE pg_class.relname='${tableName}'`,
            `AND pg_class.relnamespace IN (SELECT pg_namespace.oid FROM pg_namespace WHERE nspname = '${schemaName}')`,
            'AND pg_class.oid=pg_index.indrelid)'
        ];
    }
    visitCreateIndex(createIndexNode) {
        if (!createIndexNode.options.columns || createIndexNode.options.columns.length === 0) {
            throw new Error('No columns defined!');
        }
        const tableName = this.visit(createIndexNode.table.toNode());
        let result = ['CREATE'];
        if (createIndexNode.options.type) {
            result.push(createIndexNode.options.type.toUpperCase());
        }
        result = result.concat(['INDEX', this.quote(createIndexNode.indexName())]);
        if (createIndexNode.options.algorithm) {
            result.push('USING ' + createIndexNode.options.algorithm.toUpperCase());
        }
        result = result.concat([
            'ON',
            ...tableName,
            '(' +
                createIndexNode.options.columns.reduce((res, col) => {
                    const column = col.name ? col.name : col.value.name;
                    const direction = col instanceof node_1.OrderByValueNode ? ` ${col.direction.text}` : '';
                    return res.concat(this.quote(column) + direction);
                }, []) +
                ')'
        ]);
        if (createIndexNode.options.parser) {
            result.push('WITH PARSER');
            result.push(createIndexNode.options.parser);
        }
        return result;
    }
    visitDropIndex(dropIndexNode) {
        const result = ['DROP INDEX'];
        result.push(this.quote(dropIndexNode.table.getSchema() || 'public') + '.' + this.quote(dropIndexNode.options.indexName));
        return result;
    }
    visitCreateView(createViewNode) {
        const result = ['CREATE VIEW', this.quote(createViewNode.options.viewName), 'AS'];
        return result;
    }
    visitInterval(intervalNode) {
        let parameter = '';
        const add = (n, unit) => {
            if (!_.isNumber(n)) {
                return;
            }
            if (parameter !== '') {
                parameter += ' ';
            }
            parameter += `${n} ${unit}`;
        };
        add(intervalNode.years, 'YEAR');
        add(intervalNode.months, 'MONTH');
        add(intervalNode.days, 'DAY');
        add(intervalNode.hours, 'HOUR');
        add(intervalNode.minutes, 'MINUTE');
        add(intervalNode.seconds, 'SECOND');
        if (parameter === '') {
            parameter = '0 SECOND';
        }
        return [`INTERVAL '${parameter}'`];
    }
    /**
     * Broken out as a separate function so that dialects that derive from this class can still use this functionality.
     *
     * @param {Node[]} list
     * @param {String} type
     * @returns {Object|undefined} {index:number, node:Node}
     */
    findNode(list, type) {
        for (let i = 0, len = list.length; i < len; i++) {
            const n = list[i];
            if (n.type === type) {
                return { index: i, node: n };
            }
        }
        return undefined;
    }
    /**
     * pulls the DISTINCT node out of the filters and flags the SELECT node that it should be distinct.
     * Broken out as a separate function so that dialects that derive from this class can still use this functionality.
     */
    handleDistinct(actions, filters) {
        const distinctNode = this.findNode(filters, 'DISTINCT');
        // if (!distinctNode) distinctNode = _findNode(targets,"DISTINCT");
        // if (!distinctNode) distinctNode = _findNode(actions,"DISTINCT");
        if (!distinctNode) {
            return;
        }
        const selectInfo = this.findNode(actions, 'SELECT');
        if (!selectInfo) {
            return;
        } // there should be one by now, I think
        // mark the SELECT node that it's distinct
        selectInfo.node.isDistinct = true;
    }
}
exports.Postgres = Postgres;
/**
 * If the parent of the subquery is an INSERT we don't want to parenthesize.
 * This happens when you create the query like so:
 *
 * const query=post.insert(post.id)
 * const select=user.select(user.id)
 * query.add(select)
 *
 * @param parentQuery
 * @returns {boolean}
 */
function dontParenthesizeSubQuery(parentQuery) {
    if (!parentQuery) {
        return false;
    }
    if (parentQuery.nodes.length === 0) {
        return false;
    }
    if (['INSERT', 'REPLACE'].indexOf(parentQuery.nodes[0].type) === -1) {
        return false;
    }
    return true;
}
//# sourceMappingURL=postgres.js.map