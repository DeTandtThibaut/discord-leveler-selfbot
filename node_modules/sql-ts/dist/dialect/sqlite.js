'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const _ = require("lodash");
const postgres_1 = require("./postgres");
class Sqlite extends postgres_1.Postgres {
    constructor(config) {
        super(config);
        this.myClass = Sqlite;
        this.arrayAggFunctionName = 'GROUP_CONCAT';
        this.config = config;
        this.hasAddedAColumn = false;
    }
    _getParameterValue(value, quoteChar) {
        if (Buffer.isBuffer(value)) {
            value = 'x' + this._getParameterValue(value.toString('hex'));
        }
        else if (value instanceof Date && this.config.dateTimeMillis) {
            value = value.getTime();
        }
        else if ('boolean' === typeof value) {
            value = value ? 1 : 0;
        }
        else if (_.isArray(value)) {
            value = postgres_1.Postgres.prototype._getParameterValue.call(this, JSON.stringify(value));
        }
        else {
            value = postgres_1.Postgres.prototype._getParameterValue.call(this, value);
        }
        return value;
    }
    visitReplace(replaceNode) {
        // don't use table.column for replaces
        this.visitedReplace = true;
        let result = ['REPLACE'];
        result = result.concat(replaceNode.nodes.map((n) => this.visit(n).join()));
        result.push('INTO ' + this.visit(this.queryNode.table.toNode()));
        result.push('(' + replaceNode.columns.map(this.visit.bind(this)).join(', ') + ')');
        const paramNodes = replaceNode.getParameters();
        if (paramNodes.length > 0) {
            const paramText = paramNodes
                .map((paramSet) => {
                return paramSet.map((param) => this.visit(param)).join(', ');
            })
                .map((param) => `(${param})`)
                .join(', ');
            result.push('VALUES', paramText);
            if (result.slice(2, 5).join(' ') === '() VALUES ()') {
                result.splice(2, 3, 'DEFAULT VALUES');
            }
        }
        this.visitedReplace = false;
        return result;
    }
    visitDefault(defaultNode) {
        throw new Error('SQLite requires that all rows of a multi-row insert are for the same columns.');
    }
    visitDropColumn(dropColumnNode) {
        throw new Error('SQLite does not allow dropping columns.');
    }
    visitFunctionCall(functionCallNode) {
        this.visitingFunctionCall = true;
        const left = () => {
            // convert LEFT(column,4) to SUBSTR(column,1,4)
            const nodes = functionCallNode.nodes.map(this.visit.bind(this));
            if (nodes.length !== 2) {
                throw new Error('Not enough parameters passed to LEFT function.');
            }
            return `SUBSTR(${nodes[0] + ''}, 1, ${nodes[1] + ''})`;
        };
        const right = () => {
            // convert RIGHT(column,4) to SUBSTR(column,-4)
            const nodes = functionCallNode.nodes.map(this.visit.bind(this));
            if (nodes.length !== 2) {
                throw new Error('Not enough parameters passed to RIGHT function.');
            }
            return `SUBSTR(${nodes[0] + ''}, -${nodes[1] + ''})`;
        };
        const extract = () => {
            const nodes = functionCallNode.nodes.map(this.visit.bind(this));
            if (nodes.length !== 1) {
                throw new Error(`Not enough parameters passed to ${functionCallNode.name} function`);
            }
            let format;
            switch (functionCallNode.name) {
                case 'YEAR':
                    format = "'%Y'";
                    break;
                case 'MONTH':
                    format = "'%m'";
                    break;
                case 'DAY':
                    format = "'%d'";
                    break;
                case 'HOUR':
                    format = "'%H'";
                    break;
            }
            let col = nodes[0] + '';
            if (this.config.dateTimeMillis) {
                // Convert to a datetime before running the strftime function
                // Sqlite unix epoch is in seconds, but javascript is milliseconds.
                col = `datetime(${col}/1000, "unixepoch")`;
            }
            return `strftime(${format}, ${col})`;
        };
        let txt = '';
        const name = functionCallNode.name;
        // Override LEFT and RIGHT and convert to SUBSTR
        if (name === 'LEFT') {
            txt = left();
        }
        else if (name === 'RIGHT') {
            txt = right();
        }
        // Override date functions since sqlite uses strftime
        else if (['YEAR', 'MONTH', 'DAY', 'HOUR'].indexOf(functionCallNode.name) >= 0) {
            txt = extract();
        }
        else if ('CURRENT_TIMESTAMP' === functionCallNode.name) {
            txt = functionCallNode.name;
        }
        else {
            txt = `${name}(${functionCallNode.nodes.map(this.visit.bind(this)).join(', ')})`;
        }
        this.visitingFunctionCall = false;
        return [txt];
    }
    visitTruncate(truncateNode) {
        const result = ['DELETE FROM'];
        return result.concat(truncateNode.nodes.map((n) => this.visit(n).join()));
    }
    visitRenameColumn(renameColumnNode) {
        throw new Error('SQLite does not allow renaming columns.');
    }
    visitOnDuplicate(onDuplicateNode) {
        throw new Error('SQLite does not allow onDuplicate clause.');
    }
    visitOnConflict(onConflictNode) {
        throw new Error('Sqlite does not allow onConflict clause.');
    }
    visitReturning(returningNode) {
        throw new Error('SQLite does not allow returning clause.');
    }
    visitForUpdate(forUpdateNode) {
        throw new Error('SQLite does not allow FOR UPDATE clause.');
    }
    visitForShare(forShareNode) {
        throw new Error('SQLite does not allow FOR SHARE clause.');
    }
    visitAddColumn(addColumnNode) {
        assert(!this.hasAddedAColumn, 'SQLite can not add more that one column at a time');
        const result = postgres_1.Postgres.prototype.visitAddColumn.call(this, addColumnNode);
        this.hasAddedAColumn = true;
        return result;
    }
    visitIndexes(indexesNode) {
        const tableName = this.visit(this.queryNode.table.toNode())[0];
        return [`PRAGMA INDEX_LIST(${tableName})`];
    }
    visitCascade(cascadeNode) {
        throw new Error('Sqlite do not support CASCADE in DROP TABLE');
    }
    visitRestrict(restrictNode) {
        throw new Error('Sqlite do not support RESTRICT in DROP TABLE');
    }
    visitBinary(binaryNode) {
        if (binaryNode.operator === '@@') {
            binaryNode.operator = 'MATCH';
            const ret = super.visitBinary(binaryNode);
            binaryNode.operator = '@@';
            return ret;
        }
        return super.visitBinary(binaryNode);
    }
    visitOrIgnore(orIgnoreNode) {
        return ['OR IGNORE'];
    }
}
exports.Sqlite = Sqlite;
//# sourceMappingURL=sqlite.js.map