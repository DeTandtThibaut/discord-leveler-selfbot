/// <reference types="node" />
import { AddColumnNode, AliasNode, AlterNode, ArrayCallNode, AtNode, BinaryNode, CascadeNode, CaseNode, CastNode, ColumnNode, CreateIndexNode, CreateNode, CreateViewNode, DefaultNode, DeleteNode, DistinctNode, DistinctOnNode, DropColumnNode, DropIndexNode, DropNode, ForeignKeyNode, ForShareNode, ForUpdateNode, FromNode, FunctionCallNode, GroupByNode, HavingNode, IfExistsNode, IfNotExistsNode, IndexesNode, InNode, InsertNode, IntervalNode, JoinNode, LiteralNode, ModifierNode, Node, NotInNode, OnConflictNode, OnDuplicateNode, OrderByNode, OrderByValueNode, OrIgnoreNode, ParameterNode, PostfixUnaryNode, PrefixUnaryNode, Query, RenameColumnNode, RenameNode, ReplaceNode, RestrictNode, ReturningNode, SelectNode, SliceNode, TableNode, TernaryNode, TextNode, TruncateNode, UpdateNode, WhereNode } from '../node';
import { Table } from '../table';
import { Dialect } from './dialect';
/**
 * Config can contain:
 *
 * nullOrder: 'first' | 'last'
 *
 * @param config
 * @constructor
 */
export declare class Postgres extends Dialect {
    protected output: string[];
    protected params: string[];
    protected queryNode?: Query<any>;
    protected myClass: typeof Postgres;
    protected arrayAggFunctionName: string;
    protected aliasText: string;
    protected quoteCharacter: string;
    protected disableParameterPlaceholders: boolean;
    protected selectOrDeleteEndIndex: number;
    protected visitedInsert: boolean;
    protected visitingUpdateTargetColumn: boolean;
    protected visitingCreate: boolean;
    protected visitCreateCompoundPrimaryKey: boolean;
    protected visitingAlter: boolean;
    protected visitingCast: boolean;
    protected visitingWhere: boolean;
    protected visitingCase: boolean;
    protected visitedReplace: boolean;
    protected visitingAddColumn: boolean;
    protected visitingReturning: boolean;
    protected visitingJoin: boolean;
    protected visitingFunctionCall: boolean;
    constructor(config: any);
    _getParameterText(index: number, value: any): string;
    _getParameterValue(value: null | boolean | number | string | any[] | Date | Buffer | object, quoteChar?: string): string | number;
    _getParameterPlaceholder(index: string | number, value: any): string;
    getQuery(queryNode: Query<any> | Table<any>): {
        text: string;
        values: string[];
    };
    getString(queryNode: Query<any>): string;
    visit(node: Node): string[];
    quote(word: string, quoteCharacter?: string): string;
    visitSelect(selectNode: SelectNode): string[];
    visitInsert(insertNode: InsertNode): string[];
    visitReplace(replaceNode: ReplaceNode): string[];
    visitUpdate(updateNode: UpdateNode): string[];
    visitDelete(deleteNode: DeleteNode): string[];
    visitCreate(createNode: CreateNode): string[];
    visitDrop(dropNode: DropNode): string[];
    visitTruncate(truncateNode: TruncateNode): string[];
    visitDistinct(distinctNode: DistinctNode): string[];
    visitDistinctOn(distinctOnNode: DistinctOnNode): string[];
    visitAlias(aliasNode: AliasNode): string[];
    visitAlter(alterNode: AlterNode): string[];
    visitCast(castNode: CastNode): string[];
    visitFrom(fromNode: FromNode): string[];
    visitWhere(whereNode: WhereNode): string[];
    visitOrderBy(orderByNode: OrderByNode): string[];
    visitOrderByValue(orderByValueNode: OrderByValueNode): string[];
    visitGroupBy(groupByNode: GroupByNode): string[];
    visitHaving(havingNode: HavingNode): string[];
    visitPrefixUnary(prefixUnaryNode: PrefixUnaryNode): string[];
    visitPostfixUnary(postfixUnaryNode: PostfixUnaryNode): string[];
    visitBinary(binaryNode: BinaryNode): string[];
    visitTernary(ternaryNode: TernaryNode): string[];
    visitIn(inNode: InNode): string[];
    visitNotIn(notInNode: NotInNode): string[];
    visitCase(caseNode: CaseNode): string[];
    visitAt(atNode: AtNode): string[];
    visitSlice(sliceNode: SliceNode): string[];
    visitQuery(queryNode: Query<any>): string[];
    /**
     * We separate out this part of query building so it can be overridden by other implementations.
     *
     * @param {Node[]} actions
     * @param {Node[]} targets
     * @param {Node[]} filters
     * @returns {String[]}
     */
    visitQueryHelper(actions: Node[], targets: Node[], filters: Node[]): string[];
    visitSubquery(queryNode: Query<any>, dontParenthesize?: boolean): string[];
    visitTable(tableNode: TableNode): string[];
    visitColumn(columnNode: ColumnNode): string[];
    visitForeignKey(foreignKeyNode: ForeignKeyNode): string[];
    visitFunctionCall(functionCallNode: FunctionCallNode): string[];
    visitArrayCall(arrayCallNode: ArrayCallNode): string[];
    visitParameter(parameterNode: ParameterNode): string[];
    visitDefault(defaultNode: DefaultNode): string[];
    visitAddColumn(addColumnNode: AddColumnNode): string[];
    visitDropColumn(dropColumnNode: DropColumnNode): string[];
    visitRenameColumn(renameColumnNode: RenameColumnNode): string[];
    visitRename(renameNode: RenameNode): string[];
    visitIfExists(ifExistsNode: IfExistsNode): string[];
    visitIfNotExists(ifNotExistsNode: IfNotExistsNode): string[];
    visitOrIgnore(orIgnoreNode: OrIgnoreNode): string[];
    visitCascade(cascadeNode: CascadeNode): string[];
    visitRestrict(restrictNode: RestrictNode): string[];
    visitForUpdate(forUpdateNode: ForUpdateNode): string[];
    visitForShare(forShareNode: ForShareNode): string[];
    visitJoin(joinNode: JoinNode): string[];
    visitLiteral(literalNode: LiteralNode): string[];
    visitText(textNode: TextNode): string[];
    visitReturning(returningNode: ReturningNode): string[];
    visitOnDuplicate(onDuplicateNode: OnDuplicateNode): string[];
    visitOnConflict(onConflictNode: OnConflictNode): string[];
    visitModifier(modifierNode: ModifierNode): string[];
    visitIndexes(indexesNode: IndexesNode): string[];
    visitCreateIndex(createIndexNode: CreateIndexNode): string[];
    visitDropIndex(dropIndexNode: DropIndexNode): string[];
    visitCreateView(createViewNode: CreateViewNode): string[];
    visitInterval(intervalNode: IntervalNode): string[];
    /**
     * Broken out as a separate function so that dialects that derive from this class can still use this functionality.
     *
     * @param {Node[]} list
     * @param {String} type
     * @returns {Object|undefined} {index:number, node:Node}
     */
    findNode(list: Node[], type: string): {
        index: number;
        node: Node;
    } | undefined;
    /**
     * pulls the DISTINCT node out of the filters and flags the SELECT node that it should be distinct.
     * Broken out as a separate function so that dialects that derive from this class can still use this functionality.
     */
    handleDistinct(actions: Node[], filters: Node[]): void;
}
