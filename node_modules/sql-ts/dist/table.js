'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const lodash = require("lodash");
const column_1 = require("./column");
const joiner_1 = require("./joiner");
const node_1 = require("./node");
const sql_1 = require("./sql");
class Table {
    constructor(config) {
        this.schema = config.schema;
        this.tableName = config.name;
        this.initialConfig = config;
        this.columnWhiteList = !!config.columnWhiteList;
        this.isTemporary = !!config.isTemporary;
        this.snakeToCamel = !!config.snakeToCamel;
        this.columns = [];
        this.foreignKeys = [];
        this.table = this;
        if (!config.sql) {
            config.sql = new sql_1.Sql();
        }
        this.sql = config.sql;
        this.engine = config.engine;
        this.charset = config.charset;
    }
    get nodes() {
        return this.select(this.star()).nodes;
    }
    static define(config) {
        const table = new Table(config);
        // allow hash of columns as well as array
        if (config.columns && !Array.isArray(config.columns)) {
            const cols = [];
            for (const key in config.columns) {
                if (config.columns.hasOwnProperty(key)) {
                    const col = config.columns[key];
                    col.name = key;
                    cols.push(col);
                }
            }
            config.columns = cols;
        }
        for (const col of config.columns) {
            table.addColumn(col);
        }
        if (config.foreignKeys !== undefined) {
            if (Array.isArray(config.foreignKeys)) {
                for (const key of config.foreignKeys) {
                    table.foreignKeys.push(new node_1.ForeignKeyNode(key));
                }
            }
            else {
                table.foreignKeys.push(new node_1.ForeignKeyNode(config.foreignKeys));
            }
        }
        return table;
    }
    clone(config) {
        return Table.define(Object.assign({ columnWhiteList: !!this.columnWhiteList, columns: this.columns, foreignKeys: this.foreignKeys, name: this.tableName, schema: this.schema, snakeToCamel: !!this.snakeToCamel, sql: this.sql }, (config || {})));
    }
    createColumn(col) {
        if (!(col instanceof column_1.Column)) {
            if (typeof col === 'string') {
                // tslint:disable-next-line:no-object-literal-type-assertion
                col = { name: col };
            }
            const column = new column_1.Column(Object.assign({}, col, { table: this }));
            // Load subfields from array into an object of form name: Column
            if (Array.isArray(col.subfields)) {
                column.subfields = lodash
                    .chain(col.subfields)
                    .map((subfield) => {
                    return [
                        subfield,
                        new column_1.Column({
                            name: subfield,
                            subfieldContainer: column,
                            table: this
                        })
                    ];
                })
                    .fromPairs()
                    .value();
            }
            return column;
        }
        return col;
    }
    addColumn(col, options) {
        const column = this.createColumn(col);
        options = Object.assign({ noisy: true }, options);
        if (this.hasColumn(column)) {
            if (options.noisy) {
                throw new Error(`Table ${this.tableName} already has column or property by the name of ${column.name}`);
            }
            else {
                return this;
            }
        }
        else if (!!this[column.name] && process.env.NODE_ENV === 'debug') {
            // tslint:disable-next-line:no-console
            console.log(`Please notice that you have just defined the column "${column.name}". In order to access it, you need to use "table.getColumn('${column.name}');"!`);
        }
        this.columns.push(column);
        const snakeToCamel = (snakeName) => {
            return snakeName.replace(/[\-_]([a-z])/g, (m, $1) => $1.toUpperCase());
        };
        const property = (column.property = column.property || (this.snakeToCamel ? snakeToCamel(column.name) : column.name));
        this[property] = this[property] || column;
        return this;
    }
    hasColumn(col) {
        const columnName = col instanceof column_1.Column ? col.name : col;
        return this.columns.some((column) => column.property === columnName || column.name === columnName);
    }
    getColumn(colName) {
        for (const col of this.columns) {
            if (colName === col.property || colName === col.name) {
                return col;
            }
        }
        if (this.columnWhiteList) {
            return null;
        }
        throw new Error(`Table ${this.tableName} does not have a column or property named ${colName}`);
    }
    get(colName) {
        return this.getColumn(colName);
    }
    getSchema() {
        return this.schema;
    }
    setSchema(schema) {
        this.schema = schema;
    }
    getName() {
        if (this.sql && this.sql.dialectName === 'mssql' && this.isTemporary) {
            return `#${this.tableName}`;
        }
        return this.tableName;
    }
    star(options) {
        options = options || {};
        if ('prefix' in options) {
            return this.columns.map((column) => column.as(options.prefix + column.name));
        }
        return new column_1.Column({ table: this, star: true });
    }
    literal(literal) {
        return new node_1.LiteralNode(literal);
    }
    count(alias) {
        const name = this.alias || this.tableName;
        const col = new column_1.Column({ table: this, star: true });
        // ColumnNode
        return col.count(alias || name + '_count');
    }
    select(...args) {
        // create the query and pass it off
        const query = new node_1.Query(this);
        if (args.length === 0) {
            query.select(this.star());
        }
        else {
            query.select(...args);
        }
        return query;
    }
    subQuery(alias) {
        // create the query and pass it off
        const query = new node_1.Query(this, true);
        query.alias = alias;
        query.join = (other) => {
            return new node_1.JoinNode('INNER', this.toNode(), other.toNode());
        };
        return query;
    }
    insert(...nodes) {
        const query = new node_1.Query(this);
        if (!nodes[0] || (Array.isArray(nodes[0]) && nodes[0].length === 0)) {
            query.select(this.star());
            query.where('1=2');
        }
        else {
            query.insert(...nodes);
        }
        return query;
    }
    replace(...nodes) {
        const query = new node_1.Query(this);
        if (!nodes[0] || (Array.isArray(nodes[0]) && nodes[0].length === 0)) {
            query.select(this.star());
            query.where('1=2');
        }
        else {
            query.replace(...nodes);
        }
        return query;
    }
    toNode() {
        return new node_1.TableNode(this);
    }
    join(other) {
        return new node_1.JoinNode('INNER', this.toNode(), other.toNode());
    }
    leftJoin(other) {
        return new node_1.JoinNode('LEFT', this.toNode(), other.toNode());
    }
    // auto-join tables based on column intropsection
    joinTo(other) {
        return joiner_1.leftJoin(this, other);
    }
    as(alias) {
        // TODO could this be cleaner?
        const t = Table.define(this.initialConfig);
        t.alias = alias;
        return t;
    }
    and(...args) {
        const query = new node_1.Query(this);
        query.where(...args);
        return query;
    }
    indexes() {
        return new node_1.Query(this).indexes();
    }
}
exports.Table = Table;
const queryMethods = ['alter', 'create', 'delete', 'drop', 'from', 'limit', 'offset', 'or', 'order', 'truncate', 'update', 'where'];
queryMethods.forEach((method) => {
    Table.prototype[method] = function (...args) {
        const query = new node_1.Query(this);
        query[method].apply(query, args);
        return query;
    };
});
//# sourceMappingURL=table.js.map